package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/k0kubun/go-ansi"
	"github.com/saracen/go7z"

	"github.com/schollz/progressbar/v3"
)

var httpClient = &http.Client{}

func GetUrl(url string) (*http.Response, error) {
	return httpClient.Get(url)
}

func GetText(url string) (string, error) {
	resp, err := GetUrl(url)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(data), nil
}

func GetBytes(url string) ([]byte, error) {
	resp, err := GetUrl(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return data, nil
}

func EnsureDirExist(path string) error {
	err := os.MkdirAll(path, os.ModePerm)
	if err != nil {
		return err
	}

	return nil
}

func FileExists(path string) bool {
	_, err := os.Stat(path)

	if err == nil {
		return true
	}

	if os.IsNotExist(err) {
		return false
	}

	return false
}

func VersionFileExists(dir string) bool {
	fpath := filepath.Join(dir, ".version")
	return FileExists(fpath)

}

func GetVersionFile(dir string) (string, error) {
	// read a file
	file, err := os.Open(filepath.Join(dir, ".version"))
	if err != nil {
		return "", err
	}
	defer file.Close()

	// read file into a string
	data, err := ioutil.ReadAll(file)
	if err != nil {
		return "", err
	}

	return string(data), nil
}

func DownloadFile(url, filepath string) (err error) {
	fname := path.Base(filepath)

	// Get the data
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Check server response
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("bad status: %s", resp.Status)
	}

	// Create the file
	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()

	bar := progressbar.NewOptions(int(resp.ContentLength),
		progressbar.OptionSetWriter(ansi.NewAnsiStdout()),
		progressbar.OptionEnableColorCodes(true),
		progressbar.OptionShowBytes(true),
		progressbar.OptionSetWidth(15),
		progressbar.OptionSetDescription(fmt.Sprintf("[cyan][reset] Downloading %s...", fname)),
		progressbar.OptionSetTheme(progressbar.Theme{
			Saucer:        "[green]=[reset]",
			SaucerHead:    "[green]>[reset]",
			SaucerPadding: " ",
			BarStart:      "[",
			BarEnd:        "]",
		}))

	// Writer the body to file
	_, err = io.Copy(io.MultiWriter(out, bar), resp.Body)
	if err != nil {
		return err
	}
	println("")

	return nil
}

func DecompressWFilter(source, dest, remoteArchiveName string, filters []string) error {
	sz, err := go7z.OpenReader(source)
	if err != nil {
		return err
	}
	defer sz.Close()

	for {
		hdr, err := sz.Next()
		if err == io.EOF {
			break // End of archive
		}
		if err != nil {
			return err
		}

		// remove root directory from path
		hdr.Name = strings.TrimPrefix(hdr.Name, remoteArchiveName)

		for _, filter := range filters {
			if strings.HasPrefix(hdr.Name, filter) {
				logger.Debugf("%s matches filter %s", hdr.Name, filter)
				fname := filepath.Base(hdr.Name)
				p := filepath.Join(dest, fname)

				// If empty stream (no contents) and isn't specifically an empty file...
				// then it's a directory.
				if hdr.IsEmptyStream && !hdr.IsEmptyFile {
					if err := os.MkdirAll(p, os.ModePerm); err != nil {
						return err
					}
					continue
				}

				// Create file
				f, err := os.Create(p)
				if err != nil {
					return err
				}
				defer f.Close()

				if _, err := io.Copy(f, sz); err != nil {
					return err
				}
			}
		}
	}

	return nil
}

func WriteVersionFile(dir string, version string) error {
	header := "// This file is automatically generated DO NOT EDIT THIS FILE\n"
	// make file path
	fpath := filepath.Join(dir, ".version")
	err := ioutil.WriteFile(fpath, []byte(header+version), 0644)
	if err != nil {
		return err
	}

	return nil
}

func ReadVersionFile(dir string) (string, error) {
	// make file path
	fpath := filepath.Join(dir, ".version")
	data, err := ioutil.ReadFile(fpath)
	if err != nil {
		return "", err
	}

	lines := strings.Split(string(data), "\n")
	return lines[1], nil
}
